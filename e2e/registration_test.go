//go:build e2e
// +build e2e

package e2e

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/hashicorp/consul-terraform-sync/api"
	"github.com/hashicorp/consul-terraform-sync/config"
	"github.com/hashicorp/consul-terraform-sync/testutils"
	"github.com/hashicorp/consul/sdk/testutil"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestE2E_ServiceRegistration_Defaults(t *testing.T) {
	setParallelism(t)
	srv := testutils.NewTestConsulServer(t, testutils.TestConsulServerConfig{
		HTTPSRelPath: "../testutils",
	})
	defer srv.Stop()
	tempDir := fmt.Sprintf("%s%s", tempDirPrefix, "registration")
	taskName := "registration_w_consul"
	module := "mkam/hello/cts"

	cts := ctsSetup(t, srv, tempDir, moduleTaskConfig(taskName, module))

	// Find CTS service by name since ID is autogenerated
	name := config.DefaultServiceName
	ctsServices, err := waitForServiceByName(t, srv, name)
	require.NoError(t, err)
	require.Equal(t, 1, len(ctsServices), "unexpected number of CTS services in Consul")
	var service testutils.ConsulService
	for _, s := range ctsServices {
		service = s
	}

	// Verify service attributes
	id := service.ID
	assert.True(t, strings.HasPrefix(id, "cts-"),
		"unexpected format for generated service ID %s", service.ID)
	assert.Equal(t, name, service.Service)
	assert.Equal(t, "", service.Address)
	assert.Equal(t, cts.Port(), service.Port)
	assert.Equal(t, []string{"cts"}, service.Tags)

	// Verify health check for service
	checkID := id + "-health"
	check, err := testutils.WaitForConsulCheckStatus(t, srv, checkID, "passing", defaultWaitForCheckUpdate)
	require.NoError(t, err)
	assert.Equal(t, "http", check.Type)
	assert.Equal(t, "CTS Health Status", check.Name)
	assert.Equal(t, "passing", check.Status)
	assert.Equal(t, "Check created by Consul-Terraform-Sync", check.Notes)
	assert.Equal(t, service.ID, check.ServiceID)
	assert.Equal(t, name, check.ServiceName)
	assert.Equal(t, service.Tags, []string{"cts"})
	url := fmt.Sprintf("http://localhost:%d/v1/health", cts.Port())
	assert.Contains(t, check.Output, url)
}

func TestE2E_ServiceRegistration_Configured(t *testing.T) {
	setParallelism(t)

	srv := newTestConsulServer(t)
	defer srv.Stop()

	tempDir := fmt.Sprintf("%s%s", tempDirPrefix, "configured_registration")
	cleanup := testutils.MakeTempDir(t, tempDir)
	defer cleanup()

	// Configure CTS with a consul config that has service_registration block
	id := "cts-01"
	serviceName := "cts"
	serviceAddress := "123.456.789"
	port := testutils.FreePort(t)
	checkAddress := fmt.Sprintf("http://127.0.0.1:%d", port)
	rConfig := fmt.Sprintf(`
service_registration {
	enabled = true
	service_name = "%s"
	address = "%s"
	default_check {
		enabled = true
		address = "%s"
	}
}`, serviceName, serviceAddress, checkAddress)

	configPath := filepath.Join(tempDir, configFile)
	config := baseConfig(tempDir).appendID(id).appendPort(port).
		appendConsulBlock(srv, rConfig).appendTerraformBlock().appendDBTask()
	config.write(t, configPath)

	// Start CTS, using command directly since port has been preconfigured
	cmd := exec.Command("consul-terraform-sync", "start", fmt.Sprintf("--config-file=%s", configPath))
	err := cmd.Start()
	require.NoError(t, err)
	defer cmd.Process.Signal(os.Interrupt)
	cts, err := api.NewClient(&api.ClientConfig{URL: checkAddress}, nil)
	require.NoError(t, err)
	err = cts.WaitForTestReadiness(defaultWaitForTestReadiness)
	require.NoError(t, err)

	testutils.WaitForConsulServiceRegistered(t, srv, id, defaultWaitForRegistration)
	service, err := testutils.GetConsulService(t, srv, id)
	require.NoError(t, err, "service not registered")
	expectedSrv := testutils.ConsulService{
		Service: serviceName,
		ID:      id,
		Address: serviceAddress,
		Port:    port,
		Tags:    []string{"cts"},
	}
	assert.Equal(t, expectedSrv, service)

	checkID := id + "-health"
	check, err := testutils.WaitForConsulCheckStatus(t, srv, checkID, "passing", defaultWaitForCheckUpdate)
	require.NoError(t, err)
	assert.Equal(t, id, check.ServiceID)
	assert.Equal(t, serviceName, check.ServiceName)
	url := fmt.Sprintf("%s/v1/health", checkAddress)
	assert.Contains(t, check.Output, url)
}

func TestE2E_ServiceRegistration_DeregisterWhenStopped(t *testing.T) {
	setParallelism(t)
	srv := newTestConsulServer(t)
	defer srv.Stop()

	tempDir := fmt.Sprintf("%s%s", tempDirPrefix, "cts_stop_deregister")
	cleanup := testutils.MakeTempDir(t, tempDir)
	defer cleanup()

	id := "cts-01"
	configPath := filepath.Join(tempDir, configFile)
	config := baseConfig(tempDir).appendID(id).
		appendConsulBlock(srv).appendTerraformBlock().
		appendModuleTask("disabled_task", "mkam/hello/cts",
			"enabled = true")
	config.write(t, configPath)

	// Start CTS, verify that service is registered
	cts, stop := api.StartCTS(t, configPath)
	err := cts.WaitForTestReadiness(defaultWaitForTestReadiness)
	require.NoError(t, err)
	testutils.WaitForConsulServiceRegistered(t, srv, id, defaultWaitForRegistration)
	registered := testutils.ConsulServiceRegistered(t, srv, id)
	assert.True(t, registered)

	// Stop CTS, check that service is deregistered
	stop(t)
	testutils.WaitForConsulServiceDeregistered(t, srv, id, defaultWaitForRegistration)
	registered = testutils.ConsulServiceRegistered(t, srv, id)
	assert.False(t, registered)
}

// TestE2E_ServiceRegistration_Skipped tests scenarios where registration does
// not happen, but CTS continues to run.
func TestE2E_ServiceRegistration_Skipped(t *testing.T) {
	setParallelism(t)
	testcases := []struct {
		name   string
		config string
	}{
		{
			"registration_failure",
			`namespace = "invalid"`, // namespace is Consul ENT only
		},
		{
			"registration_disabled",
			`enabled = false`,
		},
	}

	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {

			srv := newTestConsulServer(t)
			defer srv.Stop()

			tempDir := fmt.Sprintf("%s%s", tempDirPrefix, "registration_skipped")
			cleanup := testutils.MakeTempDir(t, tempDir)
			defer cleanup()

			// Set registration configuration such that registration will not occur
			rConfig := fmt.Sprintf(`
service_registration {
	%s
}`, tc.config)
			id := "cts-01"
			configPath := filepath.Join(tempDir, configFile)
			config := baseConfig(tempDir).appendID(id).
				appendConsulBlock(srv, rConfig).appendTerraformBlock().appendDBTask()
			config.write(t, configPath)

			cts, stop := api.StartCTS(t, configPath)
			defer stop(t)
			err := cts.WaitForTestReadiness(defaultWaitForTestReadiness)
			require.NoError(t, err)

			// Should not be registered after CTS starts
			time.Sleep(1 * time.Second)
			registered := testutils.ConsulServiceRegistered(t, srv, id)
			assert.False(t, registered)

			// Trigger a task, expect CTS to continue
			now := time.Now()
			apiInstance := testutil.TestService{ID: "api_new", Name: "api"}
			testutils.RegisterConsulService(t, srv, apiInstance, defaultWaitForRegistration)
			api.WaitForEvent(t, cts, dbTaskName, now, defaultWaitForEvent)
			resourcesPath := filepath.Join(tempDir, dbTaskName, resourcesDir)
			testutils.CheckFile(t, true, resourcesPath, "api_new.txt")

			// Verify still not registered now that even more time has passed
			registered = testutils.ConsulServiceRegistered(t, srv, id)
			assert.False(t, registered)
		})
	}
}

// TestE2E_ServiceRegistration_InitError tests that if the initial run
// of all tasks fails, then CTS is still registered.
func TestE2E_ServiceRegistration_InitError(t *testing.T) {
	setParallelism(t)
	srv := newTestConsulServer(t)
	defer srv.Stop()

	tempDir := fmt.Sprintf("%s%s", tempDirPrefix, "registration_init_failure")
	cleanup := testutils.MakeTempDir(t, tempDir)
	defer cleanup()

	// Configure CTS with a task that will fail at runtime
	id := "cts-01"
	port := testutils.FreePort(t)
	configPath := filepath.Join(tempDir, configFile)
	config := baseConfig(tempDir).appendID(id).appendPort(port).
		appendConsulBlock(srv).appendTerraformBlock().
		appendModuleTask("failing_task", "./test_modules/failing_module")
	config.write(t, configPath)

	// Start CTS, use command directly to be able to check logs
	cmd := exec.Command("consul-terraform-sync", "start", fmt.Sprintf("--config-file=%s", configPath))
	var buf bytes.Buffer
	cmd.Stdout = &buf
	cmd.Stderr = &buf
	err := cmd.Start()
	require.NoError(t, err)
	defer cmd.Process.Signal(os.Interrupt)

	// Wait until CTS has exited
	exitCh := make(chan struct{})
	go func() {
		cmd.Wait()
		exitCh <- struct{}{}
	}()
	select {
	case <-exitCh:
		break
	case <-time.After(defaultWaitForTestReadiness):
		t.Fatal("timed out waiting for CTS initialization to fail")
	}

	// Verify registration and deregistration occurred
	output := buf.String()
	assert.Contains(t, output, "registering Consul-Terraform-Sync as a service with Consul")
	registered := testutils.ConsulServiceRegistered(t, srv, id)
	assert.True(t, registered)
}

func getServiceInstancesByName(t testing.TB, srv *testutil.TestServer, serviceName string) map[string]testutils.ConsulService {
	filter := fmt.Sprintf(`Service == "%s"`, serviceName)
	return testutils.ListConsulServices(t, srv, filter)
}

func waitForServiceByName(t testing.TB, srv *testutil.TestServer, serviceName string) (map[string]testutils.ConsulService, error) {
	var instances map[string]testutils.ConsulService
	polling := make(chan struct{})
	stopPolling := make(chan struct{})
	go func() {
		for {
			select {
			case <-stopPolling:
				return
			default:
				s := getServiceInstancesByName(t, srv, serviceName)
				if len(s) > 0 {
					instances = s
					polling <- struct{}{}
					return
				}
				time.Sleep(100 * time.Millisecond)
			}
		}
	}()

	select {
	case <-polling:
		return instances, nil
	case <-time.After(defaultWaitForRegistration):
		close(stopPolling)
		return instances, fmt.Errorf("timed out waiting for service %s to be registered", serviceName)
	}
}
